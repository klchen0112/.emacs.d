

* Emacs
** File Layout
*** Features
You'll notice several headings tagged with =@{feature}= like in =@mail=, these
subtrees will only be tangled if *at least one* of those features are enabled when
the config is built.

*** init.el
Everything is tangled into =init.el= by default and I don't really make any
attempt to keep this file organized since it's not really intended to be
interacted with.

#+begin_src emacs-lisp :tangle init.el
;;; init.el -*- lexical-binding: t; -*-
#+end_src

*** early-init.el :early:
=early-init.el= is tangled from the subtrees that are tagged with =early= and it
should only be used to do minimal configuration that needs to occur early in the
load sequence.

#+begin_src emacs-lisp :tangle early-init.el
;;; early-init.el -*- lexical-binding: t; -*-
#+end_src


* Early :early:
:PROPERTIES:
:header-args:emacs-lisp: :tangle early-init.el
:END:

** disable package
#+begin_src emacs-lisp
  ;; Disable package.el in favor of straight.el
  (setq package-enable-at-startup nil
        package-quickstart nil)
#+end_src
** Setup.el :early:



#+begin_src emacs-lisp
  (eval-when-compile
    (require 'setup)
    (require 'cl-lib)
  )
#+end_src
*** package :early:

#+begin_src emacs-lisp
  (eval-when-compile
      (setup-define :package
    		  (lambda (package)
  		    ()
  		      )
    	    :documentation "Fake installation of PACKAGE for twist-nix."
    	    :repeatable 
    	    ))
     
#+end_src

*** :defer

#+begin_src emacs-lisp
  (eval-when-compile
    (setup-define :defer
      		(lambda (seconds &optional func)
  		  `(add-hook 'after-init-hook
  			     (lambda ()
  			       (run-with-timer ,seconds nil
  					       ,(or func (setup-get 'hook))))))
    		:documentation         "Call a function at N seconds after init."
  		))
#+end_src
*** :reformatters
#+begin_src emacs-lisp
  (eval-when-compile
    (setup-define
     :reformatters (lambda  (&rest entries)
  		   (let ((feature (setup-get 'feature)))
  		     (macroexp-progn
  		      (mapcar (pcase-lambda (`(,name . ,args))
  				`(reformatter-define ,name ,@args))
  			      entries)))))
    :documentation "Define reformatters."
    )
#+end_src
*** :load-after
#+begin_src emacs-lisp
  (eval-when-compile
    (setup-define :load-after
  		(lambda (&rest features)
  		  (let ((body `(require ',(setup-get 'feature))))
  		    (dolist (feature (nreverse features))
  		      (setq body `(with-eval-after-load ',feature ,body)))
  		    body))
  		:documentation "Load the current feature after FEATURES.")
    )
#+end_src

*** :nixpkgs
#+begin_src emacs-lisp :yes
  (eval-when-compile
    (setup-define :nixpkgs (lambda (&rest nixpkgs) ())
     :documentation "Fake installation of packages from NIXPKGS for executables."))
#+end_src
* Basic setting
** benchmark-init
#+begin_src emacs-lisp
  (setup benchmark-init
         (:package benchmark-init)
         (:require benchmark-init)
         (:only-if init-file-debug
  		 (add-hook 'after-init-hook 'benchmark-init/deactivate))
         )
#+end_src
** treesit
#+begin_src emacs-lisp
  (setup treesit
         (:only-if (fboundp 'treesit-available-p))
         )
#+end_src
** localization
#+begin_src emacs-lisp
  (setup localization
       (:option calendar-week-start-day 1)
       )

#+end_src
* UI
** theme
#+begin_src emacs-lisp
  (setup modus-themes
         (:package modus-themes)
         (:require modus-themes)
         )
  (setup ef-themes
         (:package ef-themes)
         (:require ef-themes)
         (:option
    	ef-themes-take-over-modus-themes-mode 1)
         (:when-loaded
    	(setq modus-themes-mixed-fonts t
    	      modus-themes-italic-constructs t
    	      modus-themes-disable-other-themes t)

  	(modus-themes-load-theme 'ef-summer))
         )
#+end_src
** font
** nerd-icons
#+begin_src emacs-lisp
  (setup nerd-icons
         (:package nerd-icons))
#+end_src
** Modeline
#+begin_src emacs-lisp
  (setup dashboard
         (:package dashboard)
         (:set  dashboard-icon-type 'nerd-icons)
         (dashboard-setup-startup-hook)
         )

#+end_src

** Dashboard
#+begin_src emacs-lisp
  (setup doom-modeline
         (:package doom-modeline)
         (:hook-into after-init-hook)
         (:hook size-indication-mode)
         (:hook column-number-mode)
         )

#+end_src
** display-line-number
#+begin_src emacs-lisp
  (setup display-fill-column-indicator (:hook-into prog-mode))
  (setup display-line-numbers (:hook-into prog-mode)
         (:set display-line-numbers-width 2
  	     display-line-numbers-type 'relative))
#+end_src

** Scroll
#+begin_src emacs-lisp

  (setup pixel-scroll
         (:only-if  (version<= "29" emacs-version)
  		  (:with-mode pixel-scroll-precision-mode
  			      ;; TODO: Find a better way to hook the minor mode
  			      (:hook-into find-file-hook
  					  help-mode-hook))))
#+end_src


* Editor & Keybindings
** Copy&Paste
*** wsl copy
#+begin_src emacs-lisp
(setq select-active-regions nil)
#+end_src
** Editor Config
#+begin_src emacs-lisp
(setup editorconfig)
#+end_src
** Meow with treesitter

#+begin_src emacs-lisp
  (setup
         (:package meow)
         (:require meow)
         (defun meow-setup ()
        (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
        (meow-motion-define-key
         '("j" . meow-next)
         '("k" . meow-prev)
         '("<escape>" . ignore))
        (meow-leader-define-key
         ;; Use SPC (0-9) for digit arguments.
         '("1" . meow-digit-argument)
         '("2" . meow-digit-argument)
         '("3" . meow-digit-argument)
         '("4" . meow-digit-argument)
         '("5" . meow-digit-argument)
         '("6" . meow-digit-argument)
         '("7" . meow-digit-argument)
         '("8" . meow-digit-argument)
         '("9" . meow-digit-argument)
         '("0" . meow-digit-argument)
         '("/" . meow-keypad-describe-key)
         '("?" . meow-cheatsheet))
        (meow-normal-define-key
         '("0" . meow-expand-0)
         '("9" . meow-expand-9)
         '("8" . meow-expand-8)
         '("7" . meow-expand-7)
         '("6" . meow-expand-6)
         '("5" . meow-expand-5)
         '("4" . meow-expand-4)
         '("3" . meow-expand-3)
         '("2" . meow-expand-2)
         '("1" . meow-expand-1)
         '("-" . negative-argument)
         '(";" . meow-reverse)
         '("," . meow-inner-of-thing)
         '("." . meow-bounds-of-thing)
         '("[" . meow-beginning-of-thing)
         '("]" . meow-end-of-thing)
         '("a" . meow-append)
         '("A" . meow-open-below)
         '("b" . meow-back-word)
         '("B" . meow-back-symbol)
         '("c" . meow-change)
         '("d" . meow-delete)
         '("D" . meow-backward-delete)
         '("e" . meow-next-word)
         '("E" . meow-next-symbol)
         '("f" . meow-find)
         '("g" . meow-cancel-selection)
         '("G" . meow-grab)
         '("h" . meow-left)
         '("H" . meow-left-expand)
         '("i" . meow-insert)
         '("I" . meow-open-above)
'(      "j" . meow-next)
         '("J" . meow-next-expand)
         '("k" . meow-prev)
         '("K" . meow-prev-expand)
         '("l" . meow-right)
         '("L" . meow-right-expand)
         '("m" . meow-join)
         '("n" . meow-search)
         '("o" . meow-block)
         '("O" . meow-to-block)
         '("p" . meow-yank)
         '("q" . meow-quit)
         '("Q" . meow-goto-line)
         '("r" . meow-replace)
         '("R" . meow-swap-grab)
         '("s" . meow-kill)
         '("t" . meow-till)
         '("u" . meow-undo)
         '("U" . meow-undo-in-selection)
         '("v" . meow-visit)
         '("w" . meow-mark-word)
         '("W" . meow-mark-symbol)
         '("x" . meow-line)
         '("X" . meow-goto-line)
         '("y" . meow-save)
         '("Y" . meow-sync-grab)
         '("z" . meow-pop-selection)
         '("'" . repeat)
         '("<escape>" . ignore)))
         (:when-loaded
               (meow-setup)
               (meow-global-mode 1))
)

  (setup meow-tree-sitter
         (:package meow-tree-sitter)
         (:load-after meow)
         (:when-loaded (meow-tree-sitter-register-defaults)
         )
        )
#+end_src
** Keybiding
*** Which-key
#+begin_src emacs-lisp
(setup which-key
       (:package which-key)
       (:hook-into after-init-hook)
       (:set which-key-idle-delay 0.3)
       )

#+end_src
** Undo
Increase undo limit.
#+begin_src emacs-lisp
(setup undo-fu
       (:package undo-fu)
       (:set undo-limit 1000000
             undo-strong-limit (* 2 undo-limit))
       )
#+end_src

** Synatax & Checker

* Completion
Enable indentation and completion with the =TAB= key.
#+begin_src emacs-lisp
;; (setq tab-always-indent 'complete)
#+end_src

Cycle with the =TAB= key if there are only few candidates.
#+begin_src emacs-lisp
;; (setq completion-cycle-threshold 3)
#+end_src


** Style
*** orderless
Space-separated matching components matching in any order.
#+begin_src emacs-lisp
(setup orderless
       (:package orderless)
       (:set
        completion-styles '(substring orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Buffer
*** corfu
Completion Overlay Region FUnction.
#+begin_src emacs-lisp

(setup corfu
       (:package corfu)
       (:with-mode global-corfu-mode
  		   (:hook-into after-init-hook))
       ;; load features
       (:also-load nerd-icons-corfu)
       (:with-feature corfu-popupinfo
  		      (:set corfu-popupinfo-delay '(0.5 . 1.0))
  		      (:hook-into corfu-mode-hook))
       (:with-feature corfu-history
  		      (:hook-into corfu-mode-hook)
  		      )
       (:set
  	corfu-auto t
  	corfu-atuo-refix 2
  	corfu-cycle t
  	corfu-preselect 'prompt
  	corfu-count 16
  	corfu-max-width 120
  	corfu-on-exact-match nil
  	corfu-quit-at-boundary     'separator
  	tab-always-indent 'complete))

(setup nerd-icons-corfu
       (:package nerd-icons-corfu)
       (:also-load nerd-icons)
       )


#+end_src

** Minibuffer
*** vertico
Vertical interactive completion UI.
#+begin_src emacs-lisp
  (setup vertico
         (:package vertico)
         (:also-load orderless)
         (:also-load marginalia)
         (:hook-into after-init-hook)
         (:set vertico-cycle t)
         )


#+end_src

** snippets
#+begin_src emacs-lisp
(setup tempel
       (:package tempel)
       (:also-load tempel-collection)
       (:set tempel-trigger-prefix "<")
       ;; Setup completion at point
       (defun tempel-setup-capf ()
  	 ;; Add the Tempel Capf to `completion-at-point-functions'.
  	 ;; `tempel-expand' only triggers on exact matches. Alternatively use
  	 ;; `tempel-complete' if you want to see all matches, but then you
  	 ;; should also configure `tempel-trigger-prefix', such that Tempel
  	 ;; does not trigger too often when you don't expect it. NOTE: We add
  	 ;; `tempel-expand' *before* the main programming mode Capf, such
  	 ;; that it will be tried first.
  	 (setq-local completion-at-point-functions
  		     (cons #'tempel-expand
  			   completion-at-point-functions)))
       (add-hook 'conf-mode-hook 'tempel-setup-capf)
       (add-hook 'prog-mode-hook 'tempel-setup-capf)
       (add-hook 'text-mode-hook 'tempel-setup-capf)
       )

(setup tempel-collection
       (:package tempel-collection)
       )

#+end_src
** Extensions

*** nerd-icons-completion
#+begin_src emacs-lisp
(setup nerd-icons-completion
       (:package nerd-icons-completion)
       (:also-load nerd-icons)
       (:when-loaded
  	(add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
       )

#+end_src

*** cape
Completion At Point Extensions.
#+begin_src emacs-lisp
(setup cape
       (:package cape)
       (:when-loaded
       (add-hook 'completion-at-point-functions #'cape-dabbrev)
       (add-hook 'completion-at-point-functions #'cape-file)
       (add-hook 'completion-at-point-functions #'cape-elisp-block)
       )
       )
#+end_src

*** consult
Commands compatible with ~completing-read~.
#+begin_src emacs-lisp
(setup consult
       (:package consult)
       (:set consult-preview-key "M-RET"))

(setup consult-xref
(:when-loaded
       (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref))
       (:load-after consult xref)
       )
#+end_src
*** embark
#+begin_src emacs-lisp
  (setup embark
         (:package embark))
  (setup embark-consult
         (:package embark-consult)
         (:load-after embark consult)
         (:with-mode embark-collect-mode
  		   (:hook consult-preview-at-point-mode))
         )
#+end_src


*** dabbrev
#+begin_src emacs-lisp
(setup dabbrev
       (:set
        dabbrev-case-replace nil
        dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
#+end_src


*** marginalia
Annotations for completion candidates.
#+begin_src emacs-lisp
  (setup marginalia
         (:package marginalia)
         (:also-load nerd-icons-completion)
         (:hook-into after-init-hook))
#+end_src


* Tool 
:PROPERTIES:
:header-args:emacs-lisp: :tangle init.el
:END:
#+begin_src emacs-lisp
  ;; (setup (:package magit))
  ;;(setup (:package forge))



  (setup org
         (:package org)
         (:also-load org-modern)
         )

  (setup org-modern
         (:package org-modern)
         (:option
    	;; Edit settings
    	org-auto-align-tags nil)
         (global-org-modern-mode)
         )
   #+end_src




